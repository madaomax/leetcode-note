# [215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)

Medium



Given an integer array `nums` and an integer `k`, return *the* `kth` *largest element in the array*.

Note that it is the `kth` largest element in the sorted order, not the `kth` distinct element.

Can you solve it without sorting?

 

**Example 1:**

```
Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
```

**Example 2:**

```
Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4
```

 

**Constraints:**

- `1 <= k <= nums.length <= 105`
- `-104 <= nums[i] <= 104`





## Solution 1: Just sort

```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        """
        Summary:
            need to solve it without sorting
        Args:
            integer array `nums` and an integer `k`,
        Returns:
            kth largest element in the array.
        """
        nums = sorted(nums)
        return nums[-k]
```

time complexity O(nlogn)

python Timsort space complexity O(n)



However, the problem wants us to solve it without sorting...



## Solution 2: min-heap

Intuition: heap allows us to efficiently find the maximum or a minimum value in a dynamic dataset. 

Since the problem is asking for the kth largest element, let's push all the elements onto a min-heap, but pop from the heap when size exceeds k. When we pop, the smallest element gets removed. After processing all elements, the heap will contain exactly `k` largest elements from the array.



```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        """
        Summary:
            need to solve it without sorting
        Args:
            integer array `nums` and an integer `k`,
        Returns:
            kth largest element in the array.
        """
        heap = []
        for num in nums:
            heapq.heappush(heap, num)
            if len(heap) > k:
                heapq.heappop(heap)
        return heap[0]
```



Heap operations cost O(logk), where `k` is the size of heap.

So time complexity is O(nlogk), since k<=n, this is an improvement on the previous approach.





## Solution 3: Quickselect

Quickselect, also knwon as Hoare's selection algorithm, is an algorithm for finding kth smallest element in an unordered list. It is significant because it has an average runtime of O(n). [Wow!]

Uses the same idea as quicksort.

1. Choose a pivot index. Usually chosen reandomly.
2. Partition `nums` into 3 sections: elem == pivot, elem > pivot, and elem < pivot.
3. Count the elements in each section.
   - Denote the sections as:
   - `left` : the sections <pivot
   - `mid`: = pivot
   - `right` > pivot

Since we want the kth **largest** instead of smallest, let's swap what `left` and `right` represent. `left` will be > pivot and `right` < pivot. 

:star: If the number of elements in `left` is >= `k`, the answer must be in `left`. any other element would be less than the kth largest element. Restart the process in `left`.

:star: If number of elements in `left` and `mid` < k, the answer must be in `right`.  Restart the process in `right`. Effectively deleting elements in left and mid. which are greater than the answer, meaning that deleting them will shift `k`. Need to subtract the length of `left` and `mid` from k when we search for right. No need to shift k when we are searching in `left` because the elements we are deleting are all smaller than the target.

:star: if the answer is neither `left` or `right`, it must be in `mid`. since mid == pivot, the pivot must be the answer.



```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        """
        Summary:
            need to solve it without sorting
        Args:
            integer array `nums` and an integer `k`,
        Returns:
            kth largest element in the array.
        """
        def quick_select(nums, k):
            pivot = random.choice(nums)
            left, mid, right = [], [], []
            for num in nums:
                if num > pivot:
                    left.append(num)
                elif num < pivot:
                    right.append(num)
                else:
                    mid.append(num)
            if k <= len(left):
                return quick_select(left, k)
            if k > len(left) + len(mid):
                return quick_select(right, k - len(left) - len(mid))
            return pivot
        return quick_select(nums, k)
```

Time complexity: O(n) on average, O(n^2) in worst case.

If we choose our pivot randomly, the algorithm mathematically almost surely has a linear runtime. 

On average, the size of `nums` will decrease by a factor of 2 on each call. 

Using masters theorem:

T(n) = T(n/2) + O(n) = O(n)

Refresher on Masters theorem from CS170: https://raychan3.github.io/assets/teaching/sp17/disc02.pdf

