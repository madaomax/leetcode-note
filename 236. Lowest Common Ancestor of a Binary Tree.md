# [236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)

### Approach 1: DFS

Binary trees -> depth first search -> recursively call the function with parameters `root.left` and `root.right`. That will make it process the tree in DFS order. 

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        """
        Given a binary tree, find the lowest common ancestor of two given nodes 
        in the tree.
        LCA: the lowest common ancestor is defined between two nodes `p` and `q` 
        as the lowest node in `T` that has both `p` and `q` as descendants.
        (We allow a node to be a descendant of itself.)
        """
        # Check if we have found one of the nodes we are looking for.
        if not root or root == p or root == q:
            return root

        # Call lowestCommonAncestor recursively on left and right subtree.
        l = self.lowestCommonAncestor(root.left, p, q)
        r = self.lowestCommonAncestor(root.right, p, q)
        
        # If both l and r are not None, it means that we have found both p
        # and q in different subtrees of the current root. So,
        # the current root is the lowest common ancestor. Return current root.
        if l and r:
            return root
        
        # If one of l and r is None, we return either l or r, depending on 
        # which one is not None. If only l and r is not None, it means that 
        # the other ndoe is not in the subtree of the current root, 
        # so we return the node that is in the subtree
        return l or r
```





## Solution 2:

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        """
        Args:
            binary tree: root
            two nodes: p, q
        
        Returns:
            the lowest common ancestor between two nodes.
            The lowest node in T that has both p and q as descendants.
            A node can be a descendant of itself.
        """
        # Intuition: The LCA must either be p or q, or p and q are on 
        # left and right branch of the node, respectively.
        lca = None
        # Nested Functions in Python can read parent function's arguments.
        # So we're not passing in p and q here.
        def dfs(root: 'TreeNode') -> bool:
            '''A DFS that finds node that search for lca along the way.'''
            nonlocal lca
            if not root:
                return False
            # Return true if we found p/q in any of the paths.
            found = root.val == p.val or root.val == q.val
            # if left branch is true, means one of two nodes is found below.
            left = dfs(root.left)
            right = dfs(root.right)
            # If found, either left or right is true, root is the LCA.
            # If not found, but found both on L/R branches, root is the LCA.
            if found + left + right == 2:
                lca = root
            # Return whether this node is in the subtree at root.
            return found or left or right
        # Run DFS on the entire tree.
        dfs(root)
        return lca
```

