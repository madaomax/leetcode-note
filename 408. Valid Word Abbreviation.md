# [408. Valid Word Abbreviation](https://leetcode.com/problems/valid-word-abbreviation/)

Easy

But I feel like it is a bit of a trick question, you need to consider the corner cases carefully.



Sol 1: My solution - Two pointers + str manipulation

``````python
class Solution:
    def validWordAbbreviation(self, word: str, abbr: str) -> bool:
        """
        A string can be abreviated by replacing any number of non-adjacent, non-empty substirngs with their lengths.
        The lengths should not have leading zeros.
        Args:
            word: string
            abbr: its abbreviation
        Returns:
            (bool) whether the string matches the given abbreviation.
        """
        # index to word
        i = 0
        j = 0
        length = ""
        while i < len(word) and j < len(abbr):
            if word[i] == abbr[j]:
                i += 1
                j += 1
            # leading zero / empty substr
            elif abbr[j] == "0":
                return False
            elif abbr[j].isdigit():
                length += abbr[j]
                j += 1
                # Read entire number str
                while j < len(abbr) and abbr[j].isdigit():
                    length += abbr[j]
                    j += 1
                i += int(length)
                # Prevent skipping unchecked at end of string.
                if i > len(word):
                    return False
                length = ""
            else:
                return False
        # Both i an j need to be completely processed.
        return i == len(word) and j == len(abbr)
                
``````

Note that for two pointer questions, make sure you check the case when pointer(s) reach the end!