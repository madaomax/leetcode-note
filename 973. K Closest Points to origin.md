# 973. K Closest Points to origin

Problem description [here](https://leetcode.com/problems/k-closest-points-to-origin/description/).

Tag of question: sort.

## Solution 1: sort

1. Python solution

```python
class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        return sorted(points, key=lambda p: p[0] ** 2 + p[1] ** 2)[:k]
```

Note: `sorted()` in Python has `O(nlogn)` time complexity both on average and in worst case. Python uses [Timsort](https://en.wikipedia.org/wiki/Timsort). It is guaranteed to be stable. 



## Solution 2: min-heap

```python
class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        """
        Args: 
        1. an array of `points` where `points[i] = [x_i, y_i]` 
        represents a point on the X-Y plane and 
        2. an integer `k`, 
        
        Returns: the `k` closest points to the origin `(0, 0)`

        The distance between two points on the X-Y plane is the 
        Euclidean distance
        """
        # k smallest -> min-heap
        heap = []
        for i in range(len(points)):
            p = points[i]
            dist = -(p[0] ** 2 + p[1] ** 2)
            heapq.heappush(heap, (dist, i))
            if len(heap) > k:
                heapq.heappop(heap)
                # pop max elem
        return [points[i] for (_, i) in heap]
```

Intuition: maintaining k smallest elem -> heap

Time complexity O(nlogk), better than O(nlogn)

space complexity O(k)

