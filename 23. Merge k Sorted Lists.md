# [23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)

Hard

Linked List, D&Q, Heap, Merge sort



You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

*Merge all the linked-lists into one sorted linked-list and return it.*

 

**Example 1:**

```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6
```

**Example 2:**

```
Input: lists = []
Output: []
```

**Example 3:**

```
Input: lists = [[]]
Output: []
```

 

**Constraints:**

- `k == lists.length`
- `0 <= k <= 104`
- `0 <= lists[i].length <= 500`
- `-104 <= lists[i][j] <= 104`
- `lists[i]` is sorted in **ascending order**.
- The sum of `lists[i].length` will not exceed `104`.



## Solution 1: heap + mergesort

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        """
        Args:
            linked-list `lists`
            each list is sorted in ascneding order 
        Returns:
            The merged linked list
        """
        # sorting k smallest element -min heap?
        heap = []
        result_head = None
        current_node = None
        k = len(lists)
        if k == 0:
            return None
        for i in range(k): #O(k)
            # push the first node of each LL to the heap.
            # sort based on the value of lists
            if lists[i] is not None:
                heapq.heappush(heap, (lists[i].val, i)) # O(logk)
        
        while heap:
            # Pop minimum element from heap.
            _, i = heapq.heappop(heap)
            # Update result
            if result_head is None:
                # First iter
                result_head = lists[i]
                current_node = result_head
            else:
                current_node.next = lists[i]
                current_node = current_node.next
            # Advance this LL in lists to the next node.
            lists[i] = lists[i].next
            # Add this node to the heap.
            if lists[i] is not None:
                heapq.heappush(heap, (lists[i].val, i))
        return result_head
        
```

Intuition: 

make use of the fact that we are operating on linked list, so we can do some cool pointer tricks on the input linked lists. 



I finished this HARD problem in 18 minutes!  Runtime beats 98.67%!



Runtime O(Nlogk). Note that cost of every heap push and pop operation is `O(logk)`. Note that if we run `heapify` on an array already with elements in there, `heapify` costs `O(klogk)`. Since we are pushing every element of the linked list to the heap exactly once, so the run time is /Theta(Nlogk).