# [162. Find Peak Element](https://leetcode.com/problems/find-peak-element/)

Medium

Topic: binary search, divide and conquer

A peak element is an element that is strictly greater than its neighbors.

Given a **0-indexed** integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to **any of the peaks**.

You may imagine that `nums[-1] = nums[n] = -âˆž`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.

You must write an algorithm that runs in `O(log n)` time.

 

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
```

**Example 2:**

```
Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.
```

 

**Constraints:**

- `1 <= nums.length <= 1000`
- `-231 <= nums[i] <= 231 - 1`
- `nums[i] != nums[i + 1]` for all valid `i`.

## Solution 1 naive:

```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        """
        Summary:
            A peak element is an elem strictly greater than its neighbers.
            Must be O(logn)
        Args:
            nums. 0-indexed array nums. nums[i] != nums[i+1] for all i.
        Returns:
            index to ANY of the peaks...
        """
        # Idea: make it binary
        if len(nums) == 1:
            return 0
        if nums[0] > nums[1]:
            return 0
        if nums[-1] > nums[-2]:
            return len(nums) - 1
        for i in range(1, len(nums) - 1):
            if nums[i-1] < nums[i] > nums[i+1]:
                return i

```



## Solution 2: recursive binary search

We can view any sequence in `nums` array as alternating ascending and descending sequences. 

```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        """
        Summary:
            A peak element is an elem strictly greater than its neighbers.
            Must be O(logn)
        Args:
            nums. 0-indexed array nums. nums[i] != nums[i+1] for all i.
        Returns:
            index to ANY of the peaks...
        """
        # Idea: make it binary
        def search(l, r):
            if l == r:
                return l
            mid = (l + r) // 2
            if nums[mid] > nums[mid + 1]:
                # On a descending slope. Peak must be on the left side.
                # including mid.
                return search(l, mid)
            # On an ascending slope. Peak must be on the right side,
            # not including mid.
            return search(mid + 1, r)
        return search(0, len(nums) - 1)
```



## Solution 3: Iterative Binary Search

the same one as above.

```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        """
        Summary:
            A peak element is an elem strictly greater than its neighbers.
            Must be O(logn)
        Args:
            nums. 0-indexed array nums. nums[i] != nums[i+1] for all i.
        Returns:
            index to ANY of the peaks...
        """
        # Idea: make it binary
        l = 0
        r = len(nums) - 1
        while l < r:
            mid = (l + r) // 2
            if nums[mid] > nums[mid + 1]:
                r = mid
            else:
                l = mid + 1
        return l
```

