# [1249. Minimum Remove to Make Valid Parentheses](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/)

Medium

Given a string s of `'('` , `')'` and lowercase English characters.

Your task is to remove the minimum number of parentheses ( `'('` or `')'`, in any positions ) so that the resulting *parentheses string* is valid and return **any** valid string.

Formally, a *parentheses string* is valid if and only if:

- It is the empty string, contains only lowercase characters, or
- It can be written as `AB` (`A` concatenated with `B`), where `A` and `B` are valid strings, or
- It can be written as `(A)`, where `A` is a valid string.

 

**Example 1:**

```
Input: s = "lee(t(c)o)de)"
Output: "lee(t(c)o)de"
Explanation: "lee(t(co)de)" , "lee(t(c)ode)" would also be accepted.
```

**Example 2:**

```
Input: s = "a)b(c)d"
Output: "ab(c)d"
```

**Example 3:**

```
Input: s = "))(("
Output: ""
Explanation: An empty string is also valid.
```

 

**Constraints:**

- `1 <= s.length <= 105`
- `s[i]` is either `'('` , `')'`, or lowercase English letter.



## Solution 1 my solution:

```python
class Solution:
    def minRemoveToMakeValid(self, s: str) -> str:
        """
        Given a string s of '( and ) and lowercase English characters.
        remove the min number of paren s.t. the resulting parenthesis is valid and 
        return *any* valid string.

        Formally, a parenthesis string is valid iff:
        - it is the empty string, contains only lowercase characters, or
        - it can be written as *AB*, where A and B are valid strings, or
        - it can be written as (A), where A is a valid string.

        Args:
        s (str): input string to be removed.
        
        Returns:
        string after parenthesis removed.
        """
        # idea: stack LIFO
        # remove ) and (
        count = 0
        idx = []
        for i in range(len(s)):
            char = s[i]
            if char == '(':
                # need a ) later
                count += 1
            elif char == ')':
                if count > 0:
                    count -= 1
                else:
                    idx.append(i)

        count = 0
        for i in reversed(range(len(s))):
            char = s[i]
            if char == ')':
                count += 1
            elif char == '(':
                if count > 0:
                    count -= 1
                else:
                    idx.append(i)

        for i in reversed(sorted(idx)):
            s = s[:i] + s[i+1:]
        return s
```

Idea:

We know instantly that a back parenthesis is invalid when we are looping through the string and counting balance. Similarly, we can check if the front parenthesis is valid if we loop through the string reversely. 